"""
============================================================
Learned Rules — Auto-Generated by RuleLearningAgent
============================================================
These rules were discovered by the LLM fallback engine and
validated against MCP documentation. They follow the same
interface as deterministic rules in CodeAnalysisAgent:

    def rule_name(lines, code, sample) -> Optional[Tuple[int, str, float]]
        Returns (line_number, explanation, confidence) or None

DO NOT EDIT MANUALLY unless you understand the implications.
============================================================
"""

import re
from typing import List, Optional, Tuple

# Rule registry — maps rule_name to function
LEARNED_RULES = {}


def register_rule(name):
    """Decorator to register a learned rule."""
    def decorator(fn):
        LEARNED_RULES[name] = fn
        return fn
    return decorator


# ── Learned Rules Below ────────────────────────────────────


# ── Rule: vforce_numeric_argument ──────────────────────────────────────
# Hash: 2cf8189a0d631653
# Learned: 2026-02-10 13:18:18
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that calls to vForce provide a plain numeric value (int, float, double) without embedded unit strings.
@register_rule("vforce_numeric_argument")
def _check_vforce_numeric_argument(lines, code, sample):
    """
    Ensures that calls to vForce provide a plain numeric value (int, float, double) without embedded unit strings.
    Detection: vForce\s*\(\s*[^0-9\-+\.].*\)
    """
    try:
        pattern = re.compile(r"""vForce\s*\(\s*[^0-9\-+\.].*\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that calls to vForce provide a plain numeric value (int, float, double) without embedded unit strings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """vForce\s*\(\s*[^0-9\-+\.].*\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that calls to vForce provide a plain numeric value (int, float, double) without embedded unit strings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: invalid_addwaveform_on_waveform ──────────────────────────────────────
# Hash: ec71cd49fc211f31
# Learned: 2026-02-10 13:18:20
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Detect calls to addWaveform directly after a waveform() call, which indicates misuse of the API because addWaveform should be called on a collection or pin, not on a single Waveform object.
@register_rule("invalid_addwaveform_on_waveform")
def _check_invalid_addwaveform_on_waveform(lines, code, sample):
    """
    Detect calls to addWaveform directly after a waveform() call, which indicates misuse of the API because addWaveform should be called on a collection or pin, not on a single Waveform object.
    Detection: \.waveform\s*\([^\)]*\)\s*\.addWaveform\s*\(
    """
    try:
        pattern = re.compile(r"""\.waveform\s*\([^\)]*\)\s*\.addWaveform\s*\(""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_api_call — Detect calls to addWaveform directly after a waveform() call, which indicates misuse of the API because addWaveform should be called on a collection or pin, not on a single Waveform object."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.92)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """\.waveform\s*\([^\)]*\)\s*\.addWaveform\s*\(""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_api_call — Detect calls to addWaveform directly after a waveform() call, which indicates misuse of the API because addWaveform should be called on a collection or pin, not on a single Waveform object."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.92)
    return None


# ── Rule: smartvec_readmode_invalid_enum ──────────────────────────────────────
# Hash: 611a17844b335d5c
# Learned: 2026-02-10 13:18:21
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that calls to SmartVec::readMode use a value from the SmartVec::ReadMode enumeration rather than an unrelated enum.
@register_rule("smartvec_readmode_invalid_enum")
def _check_smartvec_readmode_invalid_enum(lines, code, sample):
    """
    Ensures that calls to SmartVec::readMode use a value from the SmartVec::ReadMode enumeration rather than an unrelated enum.
    Detection: Detect calls to readMode\s*\(\s*[^:]+::[^)]+\s*\) where the argument's type is not SmartVec::ReadMode
    """
    try:
        pattern = re.compile(r"""Detect calls to readMode\s*\(\s*[^:]+::[^)]+\s*\) where the argument's type is not SmartVec::ReadMode""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument — Ensures that calls to SmartVec::readMode use a value from the SmartVec::ReadMode enumeration rather than an unrelated enum."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.88)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """Detect calls to readMode\s*\(\s*[^:]+::[^)]+\s*\) where the argument's type is not SmartVec::ReadMode""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument — Ensures that calls to SmartVec::readMode use a value from the SmartVec::ReadMode enumeration rather than an unrelated enum."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.88)
    return None


# ── Rule: vforce_numeric_argument ──────────────────────────────────────
# Hash: 928d8344c28b5c6d
# Learned: 2026-02-10 13:18:25
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that the vForce API is called with a pure numeric argument (float/double) without embedded unit strings.
@register_rule("vforce_numeric_argument")
def _check_vforce_numeric_argument(lines, code, sample):
    """
    Ensures that the vForce API is called with a pure numeric argument (float/double) without embedded unit strings.
    Detection: vForce\s*\(\s*[^\d]*\d+\s+[A-Za-z]+\s*\)
    """
    try:
        pattern = re.compile(r"""vForce\s*\(\s*[^\d]*\d+\s+[A-Za-z]+\s*\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that the vForce API is called with a pure numeric argument (float/double) without embedded unit strings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """vForce\s*\(\s*[^\d]*\d+\s+[A-Za-z]+\s*\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that the vForce API is called with a pure numeric argument (float/double) without embedded unit strings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: rdi_vforce_argument_must_be_numeric ──────────────────────────────────────
# Hash: 5f5f31ede6472ca8
# Learned: 2026-02-10 13:24:20
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that calls to rdi.dc().pin(...).vForce(...) provide a plain numeric value (int, float, double) without unit suffixes or invalid tokens.
@register_rule("rdi_vforce_argument_must_be_numeric")
def _check_rdi_vforce_argument_must_be_numeric(lines, code, sample):
    """
    Ensures that calls to rdi.dc().pin(...).vForce(...) provide a plain numeric value (int, float, double) without unit suffixes or invalid tokens.
    Detection: vForce\s*\(\s*[^0-9\-+\.\)]+\s*\)
    """
    try:
        pattern = re.compile(r"""vForce\s*\(\s*[^0-9\-+\.\)]+\s*\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_literal — Ensures that calls to rdi.dc().pin(...).vForce(...) provide a plain numeric value (int, float, double) without unit suffixes or invalid tokens."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """vForce\s*\(\s*[^0-9\-+\.\)]+\s*\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_literal — Ensures that calls to rdi.dc().pin(...).vForce(...) provide a plain numeric value (int, float, double) without unit suffixes or invalid tokens."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: invalid_method_sequence_after_waveform ──────────────────────────────────────
# Hash: 3acbb32f6654ea37
# Learned: 2026-02-10 13:24:26
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Detect calls to collection‑modifying methods (e.g., addWaveform) directly after a waveform() call, which returns a Waveform object that does not support those methods.
@register_rule("invalid_method_sequence_after_waveform")
def _check_invalid_method_sequence_after_waveform(lines, code, sample):
    """
    Detect calls to collection‑modifying methods (e.g., addWaveform) directly after a waveform() call, which returns a Waveform object that does not support those methods.
    Detection: \.waveform\([^)]*\)\.addWaveform\(
    """
    try:
        pattern = re.compile(r"""\.waveform\([^)]*\)\.addWaveform\(""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_api_call — Detect calls to collection‑modifying methods (e.g., addWaveform) directly after a waveform() call, which returns a Waveform object that does not support those methods."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.94)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """\.waveform\([^)]*\)\.addWaveform\(""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_api_call — Detect calls to collection‑modifying methods (e.g., addWaveform) directly after a waveform() call, which returns a Waveform object that does not support those methods."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.94)
    return None


# ── Rule: rdi_vforce_numeric_argument ──────────────────────────────────────
# Hash: f0357e56217d5670
# Learned: 2026-02-10 13:24:29
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that the argument passed to rdi.dc().pin(...).vForce(...) is a numeric value or a defined voltage constant, not a string or malformed literal.
@register_rule("rdi_vforce_numeric_argument")
def _check_rdi_vforce_numeric_argument(lines, code, sample):
    """
    Ensures that the argument passed to rdi.dc().pin(...).vForce(...) is a numeric value or a defined voltage constant, not a string or malformed literal.
    Detection: vForce\s*\(\s*[^0-9\-\.]+\s*\)
    """
    try:
        pattern = re.compile(r"""vForce\s*\(\s*[^0-9\-\.]+\s*\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that the argument passed to rdi.dc().pin(...).vForce(...) is a numeric value or a defined voltage constant, not a string or malformed literal."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """vForce\s*\(\s*[^0-9\-\.]+\s*\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that the argument passed to rdi.dc().pin(...).vForce(...) is a numeric value or a defined voltage constant, not a string or malformed literal."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: missing_execute ──────────────────────────────────────
# Hash: 523dd05d00a41a9e
# Learned: 2026-02-10 13:55:30
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that any RDI command chain (e.g., dc, ac, vec) is concluded with a .execute() call before ending the lifecycle.
@register_rule("missing_execute")
def _check_missing_execute(lines, code, sample):
    """
    Ensures that any RDI command chain (e.g., dc, ac, vec) is concluded with a .execute() call before ending the lifecycle.
    Detection: rdi\.[a-zA-Z]+\([^)]*\)(?!.*\.execute\(\))
    """
    try:
        pattern = re.compile(r"""rdi\.[a-zA-Z]+\([^)]*\)(?!.*\.execute\(\))""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: missing_execute — Ensures that any RDI command chain (e.g., dc, ac, vec) is concluded with a .execute() call before ending the lifecycle."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """rdi\.[a-zA-Z]+\([^)]*\)(?!.*\.execute\(\))""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: missing_execute — Ensures that any RDI command chain (e.g., dc, ac, vec) is concluded with a .execute() call before ending the lifecycle."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: run_time_val_array_not_allowed ──────────────────────────────────────
# Hash: 36e36fa0d27d89cd
# Learned: 2026-02-10 13:55:32
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that rdi.runTimeVal is called only with scalar numeric arguments, not with array or container types.
@register_rule("run_time_val_array_not_allowed")
def _check_run_time_val_array_not_allowed(lines, code, sample):
    """
    Ensures that rdi.runTimeVal is called only with scalar numeric arguments, not with array or container types.
    Detection: rdi\.runTimeVal\s*\(\s*\"[^\"]+\"\s*,\s*[^\)]+\)\s*;\s*// flag if second argument is of type ARRAY_ or std::vector
    """
    try:
        pattern = re.compile(r"""rdi\.runTimeVal\s*\(\s*\"[^\"]+\"\s*,\s*[^\)]+\)\s*;\s*// flag if second argument is of type ARRAY_ or std::vector""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that rdi.runTimeVal is called only with scalar numeric arguments, not with array or container types."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.94)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """rdi\.runTimeVal\s*\(\s*\"[^\"]+\"\s*,\s*[^\)]+\)\s*;\s*// flag if second argument is of type ARRAY_ or std::vector""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that rdi.runTimeVal is called only with scalar numeric arguments, not with array or container types."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.94)
    return None


# ── Rule: dc_chain_requires_execute ──────────────────────────────────────
# Hash: 370e692e808e006e
# Learned: 2026-02-10 13:55:34
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: All RDI DC configuration chains must end with a call to .execute() to commit the settings.
@register_rule("dc_chain_requires_execute")
def _check_dc_chain_requires_execute(lines, code, sample):
    """
    All RDI DC configuration chains must end with a call to .execute() to commit the settings.
    Detection: rdi\.dc\(\).*\.(?!execute\(\)).*$
    """
    try:
        pattern = re.compile(r"""rdi\.dc\(\).*\.(?!execute\(\)).*$""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: missing_execute — All RDI DC configuration chains must end with a call to .execute() to commit the settings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """rdi\.dc\(\).*\.(?!execute\(\)).*$""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: missing_execute — All RDI DC configuration chains must end with a call to .execute() to commit the settings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: missing_execute ──────────────────────────────────────
# Hash: 0ec0778d898a08fd
# Learned: 2026-02-10 13:55:36
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that any RDI/SmartRDI configuration chain (e.g., dc(), smartVec(), etc.) ends with an .execute() call before the statement terminates.
@register_rule("missing_execute")
def _check_missing_execute(lines, code, sample):
    """
    Ensures that any RDI/SmartRDI configuration chain (e.g., dc(), smartVec(), etc.) ends with an .execute() call before the statement terminates.
    Detection: rdi\.[a-zA-Z]+\([^\)]*\)(?:\.[a-zA-Z_]+\([^\)]*\))*\s*;(?!.*\.execute\s*\()
    """
    try:
        pattern = re.compile(r"""rdi\.[a-zA-Z]+\([^\)]*\)(?:\.[a-zA-Z_]+\([^\)]*\))*\s*;(?!.*\.execute\s*\()""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: missing_execute — Ensures that any RDI/SmartRDI configuration chain (e.g., dc(), smartVec(), etc.) ends with an .execute() call before the statement terminates."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.94)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """rdi\.[a-zA-Z]+\([^\)]*\)(?:\.[a-zA-Z_]+\([^\)]*\))*\s*;(?!.*\.execute\s*\()""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: missing_execute — Ensures that any RDI/SmartRDI configuration chain (e.g., dc(), smartVec(), etc.) ends with an .execute() call before the statement terminates."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.94)
    return None


# ── Rule: missing_lifecycle_end ──────────────────────────────────────
# Hash: e0f9f51b26c99ba1
# Learned: 2026-02-10 13:55:38
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that every RDI_BEGIN() is paired with a corresponding RDI_END() within the same scope.
@register_rule("missing_lifecycle_end")
def _check_missing_lifecycle_end(lines, code, sample):
    """
    Ensures that every RDI_BEGIN() is paired with a corresponding RDI_END() within the same scope.
    Detection: Detect a call to RDI_BEGIN() without a subsequent RDI_END() before the end of the function or block.
    """
    try:
        pattern = re.compile(r"""Detect a call to RDI_BEGIN() without a subsequent RDI_END() before the end of the function or block.""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: missing_lifecycle_end — Ensures that every RDI_BEGIN() is paired with a corresponding RDI_END() within the same scope."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """Detect a call to RDI_BEGIN() without a subsequent RDI_END() before the end of the function or block.""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: missing_lifecycle_end — Ensures that every RDI_BEGIN() is paired with a corresponding RDI_END() within the same scope."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: consistent_identifier_usage ──────────────────────────────────────
# Hash: 4e622b097e8de2ce
# Learned: 2026-02-10 13:55:41
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that the identifier string used in measurement setup (e.g., func, pin, digCap) matches the identifier used in subsequent retrieval calls (e.g., id, get...).
@register_rule("consistent_identifier_usage")
def _check_consistent_identifier_usage(lines, code, sample):
    """
    Ensures that the identifier string used in measurement setup (e.g., func, pin, digCap) matches the identifier used in subsequent retrieval calls (e.g., id, get...).
    Detection: Look for a setup chain containing .func\(\"([^\"]+)\"\).* followed by a later call .id\(\"(?!\1)[^\"]+\"\)
    """
    try:
        pattern = re.compile(r"""Look for a setup chain containing .func\(\"([^\"]+)\"\).* followed by a later call .id\(\"(?!\1)[^\"]+\"\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: variable_mismatch — Ensures that the identifier string used in measurement setup (e.g., func, pin, digCap) matches the identifier used in subsequent retrieval calls (e.g., id, get...)."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """Look for a setup chain containing .func\(\"([^\"]+)\"\).* followed by a later call .id\(\"(?!\1)[^\"]+\"\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: variable_mismatch — Ensures that the identifier string used in measurement setup (e.g., func, pin, digCap) matches the identifier used in subsequent retrieval calls (e.g., id, get...)."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None

