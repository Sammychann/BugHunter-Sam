"""
============================================================
Learned Rules — Auto-Generated by RuleLearningAgent
============================================================
These rules were discovered by the LLM fallback engine and
validated against MCP documentation. They follow the same
interface as deterministic rules in CodeAnalysisAgent:

    def rule_name(lines, code, sample) -> Optional[Tuple[int, str, float]]
        Returns (line_number, explanation, confidence) or None

DO NOT EDIT MANUALLY unless you understand the implications.
============================================================
"""

import re
from typing import List, Optional, Tuple

# Rule registry — maps rule_name to function
LEARNED_RULES = {}


def register_rule(name):
    """Decorator to register a learned rule."""
    def decorator(fn):
        LEARNED_RULES[name] = fn
        return fn
    return decorator


# ── Learned Rules Below ────────────────────────────────────


# ── Rule: vforce_numeric_argument ──────────────────────────────────────
# Hash: 2cf8189a0d631653
# Learned: 2026-02-10 13:18:18
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that calls to vForce provide a plain numeric value (int, float, double) without embedded unit strings.
@register_rule("vforce_numeric_argument")
def _check_vforce_numeric_argument(lines, code, sample):
    """
    Ensures that calls to vForce provide a plain numeric value (int, float, double) without embedded unit strings.
    Detection: vForce\s*\(\s*[^0-9\-+\.].*\)
    """
    try:
        pattern = re.compile(r"""vForce\s*\(\s*[^0-9\-+\.].*\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that calls to vForce provide a plain numeric value (int, float, double) without embedded unit strings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """vForce\s*\(\s*[^0-9\-+\.].*\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that calls to vForce provide a plain numeric value (int, float, double) without embedded unit strings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: invalid_addwaveform_on_waveform ──────────────────────────────────────
# Hash: ec71cd49fc211f31
# Learned: 2026-02-10 13:18:20
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Detect calls to addWaveform directly after a waveform() call, which indicates misuse of the API because addWaveform should be called on a collection or pin, not on a single Waveform object.
@register_rule("invalid_addwaveform_on_waveform")
def _check_invalid_addwaveform_on_waveform(lines, code, sample):
    """
    Detect calls to addWaveform directly after a waveform() call, which indicates misuse of the API because addWaveform should be called on a collection or pin, not on a single Waveform object.
    Detection: \.waveform\s*\([^\)]*\)\s*\.addWaveform\s*\(
    """
    try:
        pattern = re.compile(r"""\.waveform\s*\([^\)]*\)\s*\.addWaveform\s*\(""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_api_call — Detect calls to addWaveform directly after a waveform() call, which indicates misuse of the API because addWaveform should be called on a collection or pin, not on a single Waveform object."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.92)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """\.waveform\s*\([^\)]*\)\s*\.addWaveform\s*\(""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_api_call — Detect calls to addWaveform directly after a waveform() call, which indicates misuse of the API because addWaveform should be called on a collection or pin, not on a single Waveform object."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.92)
    return None


# ── Rule: smartvec_readmode_invalid_enum ──────────────────────────────────────
# Hash: 611a17844b335d5c
# Learned: 2026-02-10 13:18:21
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that calls to SmartVec::readMode use a value from the SmartVec::ReadMode enumeration rather than an unrelated enum.
@register_rule("smartvec_readmode_invalid_enum")
def _check_smartvec_readmode_invalid_enum(lines, code, sample):
    """
    Ensures that calls to SmartVec::readMode use a value from the SmartVec::ReadMode enumeration rather than an unrelated enum.
    Detection: Detect calls to readMode\s*\(\s*[^:]+::[^)]+\s*\) where the argument's type is not SmartVec::ReadMode
    """
    try:
        pattern = re.compile(r"""Detect calls to readMode\s*\(\s*[^:]+::[^)]+\s*\) where the argument's type is not SmartVec::ReadMode""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument — Ensures that calls to SmartVec::readMode use a value from the SmartVec::ReadMode enumeration rather than an unrelated enum."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.88)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """Detect calls to readMode\s*\(\s*[^:]+::[^)]+\s*\) where the argument's type is not SmartVec::ReadMode""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument — Ensures that calls to SmartVec::readMode use a value from the SmartVec::ReadMode enumeration rather than an unrelated enum."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.88)
    return None


# ── Rule: vforce_numeric_argument ──────────────────────────────────────
# Hash: 928d8344c28b5c6d
# Learned: 2026-02-10 13:18:25
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that the vForce API is called with a pure numeric argument (float/double) without embedded unit strings.
@register_rule("vforce_numeric_argument")
def _check_vforce_numeric_argument(lines, code, sample):
    """
    Ensures that the vForce API is called with a pure numeric argument (float/double) without embedded unit strings.
    Detection: vForce\s*\(\s*[^\d]*\d+\s+[A-Za-z]+\s*\)
    """
    try:
        pattern = re.compile(r"""vForce\s*\(\s*[^\d]*\d+\s+[A-Za-z]+\s*\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that the vForce API is called with a pure numeric argument (float/double) without embedded unit strings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """vForce\s*\(\s*[^\d]*\d+\s+[A-Za-z]+\s*\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that the vForce API is called with a pure numeric argument (float/double) without embedded unit strings."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: rdi_vforce_argument_must_be_numeric ──────────────────────────────────────
# Hash: 5f5f31ede6472ca8
# Learned: 2026-02-10 13:24:20
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that calls to rdi.dc().pin(...).vForce(...) provide a plain numeric value (int, float, double) without unit suffixes or invalid tokens.
@register_rule("rdi_vforce_argument_must_be_numeric")
def _check_rdi_vforce_argument_must_be_numeric(lines, code, sample):
    """
    Ensures that calls to rdi.dc().pin(...).vForce(...) provide a plain numeric value (int, float, double) without unit suffixes or invalid tokens.
    Detection: vForce\s*\(\s*[^0-9\-+\.\)]+\s*\)
    """
    try:
        pattern = re.compile(r"""vForce\s*\(\s*[^0-9\-+\.\)]+\s*\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_literal — Ensures that calls to rdi.dc().pin(...).vForce(...) provide a plain numeric value (int, float, double) without unit suffixes or invalid tokens."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """vForce\s*\(\s*[^0-9\-+\.\)]+\s*\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_literal — Ensures that calls to rdi.dc().pin(...).vForce(...) provide a plain numeric value (int, float, double) without unit suffixes or invalid tokens."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None


# ── Rule: invalid_method_sequence_after_waveform ──────────────────────────────────────
# Hash: 3acbb32f6654ea37
# Learned: 2026-02-10 13:24:26
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Detect calls to collection‑modifying methods (e.g., addWaveform) directly after a waveform() call, which returns a Waveform object that does not support those methods.
@register_rule("invalid_method_sequence_after_waveform")
def _check_invalid_method_sequence_after_waveform(lines, code, sample):
    """
    Detect calls to collection‑modifying methods (e.g., addWaveform) directly after a waveform() call, which returns a Waveform object that does not support those methods.
    Detection: \.waveform\([^)]*\)\.addWaveform\(
    """
    try:
        pattern = re.compile(r"""\.waveform\([^)]*\)\.addWaveform\(""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_api_call — Detect calls to collection‑modifying methods (e.g., addWaveform) directly after a waveform() call, which returns a Waveform object that does not support those methods."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.94)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """\.waveform\([^)]*\)\.addWaveform\(""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_api_call — Detect calls to collection‑modifying methods (e.g., addWaveform) directly after a waveform() call, which returns a Waveform object that does not support those methods."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.94)
    return None


# ── Rule: rdi_vforce_numeric_argument ──────────────────────────────────────
# Hash: f0357e56217d5670
# Learned: 2026-02-10 13:24:29
# Severity: HIGH
# Source: LLM (Groq OSS-120B) + MCP Validation
# Description: Ensures that the argument passed to rdi.dc().pin(...).vForce(...) is a numeric value or a defined voltage constant, not a string or malformed literal.
@register_rule("rdi_vforce_numeric_argument")
def _check_rdi_vforce_numeric_argument(lines, code, sample):
    """
    Ensures that the argument passed to rdi.dc().pin(...).vForce(...) is a numeric value or a defined voltage constant, not a string or malformed literal.
    Detection: vForce\s*\(\s*[^0-9\-\.]+\s*\)
    """
    try:
        pattern = re.compile(r"""vForce\s*\(\s*[^0-9\-\.]+\s*\)""", re.IGNORECASE)
        for line_obj in lines:
            if pattern.search(line_obj.stripped):
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that the argument passed to rdi.dc().pin(...).vForce(...) is a numeric value or a defined voltage constant, not a string or malformed literal."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    except re.error:
        # If the pattern is not valid regex, use substring matching
        search_term = """vForce\s*\(\s*[^0-9\-\.]+\s*\)""".lower()
        for line_obj in lines:
            if search_term in line_obj.stripped.lower():
                explanation = (
                    f"Line {line_obj.line_number}: invalid_argument_type — Ensures that the argument passed to rdi.dc().pin(...).vForce(...) is a numeric value or a defined voltage constant, not a string or malformed literal."
                    f" |"
                    f" | Impact: Potential API misuse detected."
                )
                return (line_obj.line_number, explanation, 0.96)
    return None

